<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Phobos — Spinning Moon</title>

<!-- Minimal, modern styling -->
<style>
  :root{
    --bg1: #05060a;
    --bg2: #0b1220;
    --glass: rgba(255,255,255,0.06);
    --glass-border: rgba(255,255,255,0.12);
    --accent: #9be7ff;
    --max-width: 1100px;
  }

  html,body{
    height:100%;
    margin:0;
    font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: radial-gradient(1200px circle at 10% 20%, rgba(9,15,30,0.85), transparent 10%),
                linear-gradient(180deg, var(--bg1) 0%, var(--bg2) 100%);
    color: #e6eef6;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    overflow:hidden;
  }

  /* full canvas container */
  #canvas-wrap{
    width:100%;
    height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    position:relative;
  }

  canvas { display:block; max-width:100%; }

  /* top glass text box */
  .topbox {
    position: absolute;
    top: clamp(18px, 3.2vh, 36px);
    left: 50%;
    transform: translateX(-50%);
    width: min(920px, calc(100% - 48px));
    max-width: var(--max-width);
    padding: 18px 22px;
    border-radius: 14px;
    background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(255,255,255,0.02));
    box-shadow: 0 6px 18px rgba(3,7,15,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    border: 1px solid var(--glass-border);
    backdrop-filter: blur(8px) saturate(120%);
    -webkit-backdrop-filter: blur(8px) saturate(120%);
    display:flex;
    gap:12px;
    align-items:center;
  }

  .topbox .title {
    font-size: clamp(16px, 2.2vh, 20px);
    font-weight:600;
    letter-spacing:0.2px;
  }
  .topbox .subtitle{
    font-size: clamp(12px, 1.6vh, 14px);
    opacity:0.85;
    margin-left:auto;
    display:flex;
    gap:10px;
    align-items:center;
  }

  .badge{
    background: rgba(155,231,255,0.06);
    border:1px solid rgba(155,231,255,0.12);
    padding:6px 10px;
    border-radius:999px;
    font-weight:600;
    color:var(--accent);
    font-size:13px;
    box-shadow: 0 2px 6px rgba(24,40,60,0.25);
  }

  /* bottom left info */
  .info {
    position:absolute;
    left:20px;
    bottom:20px;
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:10px;
    padding:10px 14px;
    font-size:13px;
    border:1px solid rgba(255,255,255,0.03);
    backdrop-filter: blur(6px);
  }

  /* small responsive tweaks */
  @media (max-width:520px){
    .topbox { padding:12px 14px; border-radius:12px; }
    .badge{ padding:6px 8px; font-size:12px; }
  }
</style>
</head>
<body>
  <div id="canvas-wrap">
    <!-- Three.js renderer attaches here -->
    <canvas id="three-canvas"></canvas>

    <!-- Glassy top text box -->
    <div class="topbox" aria-live="polite">
      <div style="display:flex;flex-direction:column;">
        <div class="title">Phobos — Rapid Spin Demo</div>
        <div class="subtitle" style="margin-top:6px; opacity:0.9; font-weight:500; font-size:13px;">
          Procedural surface • Bump-mapped • Interactive
        </div>
      </div>

      <div class="subtitle">
        <div class="badge">Orbit Controls</div>
      </div>
    </div>

    <div class="info">Drag to rotate · Scroll to zoom · Resize window to fit</div>
  </div>

<!-- Import Three.js as module and OrbitControls -->
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.module.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.152.2/examples/jsm/controls/OrbitControls.js';

const canvasWrap = document.getElementById('canvas-wrap');
const canvas = document.getElementById('three-canvas');

const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.setSize(canvasWrap.clientWidth, canvasWrap.clientHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;

const scene = new THREE.Scene();

// camera
const camera = new THREE.PerspectiveCamera(45, canvasWrap.clientWidth / canvasWrap.clientHeight, 0.1, 2000);
camera.position.set(0, 0.6, 3.6);

// subtle ambient + key lights
const ambient = new THREE.AmbientLight(0xffffff, 0.35);
scene.add(ambient);

const key = new THREE.DirectionalLight(0xfff6e6, 1.0);
key.position.set(5, 3, 2);
scene.add(key);

const fill = new THREE.PointLight(0x99caff, 0.4);
fill.position.set(-4, -2, -2);
scene.add(fill);

// starfield using points (aesthetic background)
function addStarfield() {
  const starsGeometry = new THREE.BufferGeometry();
  const starCount = 1200;
  const positions = new Float32Array(starCount * 3);
  for (let i = 0; i < starCount; i++) {
    const r = 60 + Math.random() * 120; // spread far away
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos((Math.random() * 2) - 1);
    positions[3 * i + 0] = r * Math.sin(phi) * Math.cos(theta);
    positions[3 * i + 1] = r * Math.sin(phi) * Math.sin(theta);
    positions[3 * i + 2] = r * Math.cos(phi);
  }
  starsGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  const starsMaterial = new THREE.PointsMaterial({
    size: 0.08,
    transparent: true,
    opacity: 0.85,
    depthWrite: false
  });
  const stars = new THREE.Points(starsGeometry, starsMaterial);
  scene.add(stars);
}
addStarfield();

/* ---------- Procedural texture generation ----------
   We'll create color and bump canvases (no external images).
   A simple layered noise + radial darkening is used to emulate
   a cratered, rocky moon surface.
-----------------------------------------------------*/

function generateNoise(width, height, layers = 5) {
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');

  const img = ctx.createImageData(width, height);
  // layer multiple octaves of smoothed random noise
  const tmp = new Float32Array(width * height).fill(0);

  for (let octave = 0; octave < layers; octave++) {
    const scale = Math.pow(2, octave);
    const amp = Math.pow(0.55, octave) * (0.9 - octave * 0.07);
    // create a very low-res noise and bilinear upscale-ish
    const rx = Math.max(2, Math.floor(width / scale));
    const ry = Math.max(2, Math.floor(height / scale));
    const base = [];
    for (let y = 0; y < ry; y++){
      for (let x = 0; x < rx; x++){
        base.push(Math.random() * 2 - 1);
      }
    }
    // sample base into tmp
    for (let y=0;y<height;y++){
      const fy = y / (height - 1) * (ry - 1);
      const iy = Math.floor(fy), ryf = fy - iy;
      for (let x=0;x<width;x++){
        const fx = x / (width - 1) * (rx - 1);
        const ix = Math.floor(fx), rxf = fx - ix;
        // bilinear interpolation
        const a = base[iy * rx + ix];
        const b = base[iy * rx + Math.min(ix + 1, rx - 1)];
        const c = base[Math.min(iy + 1, ry - 1) * rx + ix];
        const d = base[Math.min(iy + 1, ry - 1) * rx + Math.min(ix + 1, rx - 1)];
        const ab = a + (b - a) * rxf;
        const cd = c + (d - c) * rxf;
        const val = ab + (cd - ab) * ryf;
        tmp[y * width + x] += val * amp;
      }
    }
  }

  // normalize tmp to 0..1 and write to image
  let min = Infinity, max = -Infinity;
  for (let i=0;i<tmp.length;i++){
    if (tmp[i] < min) min = tmp[i];
    if (tmp[i] > max) max = tmp[i];
  }
  const span = max - min || 1;
  for (let y=0;y<height;y++){
    for (let x=0;x<width;x++){
      const v = (tmp[y*width + x] - min) / span;
      const idx = (y*width + x) * 4;
      // radial darkening from edges to center to create sense of relief
      const nx = x/width - 0.5, ny = y/height - 0.5;
      const dist = Math.sqrt(nx*nx + ny*ny) / Math.sqrt(0.5);
      const darken = Math.pow(dist, 2.2);
      const final = Math.max(0, Math.min(1, v * (1 - 0.26 * darken)));
      const tone = Math.floor(final * 255);
      img.data[idx] = tone;
      img.data[idx+1] = Math.floor(tone * 0.96);
      img.data[idx+2] = Math.floor(tone * 0.9);
      img.data[idx+3] = 255;
    }
  }
  ctx.putImageData(img, 0, 0);
  return canvas;
}

// color texture (slightly desaturated, rocky)
const colorTexCanvas = document.createElement('canvas');
colorTexCanvas.width = 2048;
colorTexCanvas.height = 1024;
{
  const c = generateNoise(colorTexCanvas.width, colorTexCanvas.height, 6);
  const ctx = colorTexCanvas.getContext('2d');
  ctx.fillStyle = '#3c3a3a';
  // draw base then overlay noise to produce real-looking moon surface
  ctx.fillRect(0,0,colorTexCanvas.width,colorTexCanvas.height);
  ctx.globalCompositeOperation = 'lighter';
  ctx.drawImage(c, 0, 0, colorTexCanvas.width, colorTexCanvas.height);
  // add some color variation (rusty and bluish hints)
  const im = ctx.getImageData(0,0,colorTexCanvas.width,colorTexCanvas.height);
  for (let i=0;i<im.data.length;i+=4){
    const v = im.data[i] / 255;
    // subtle color mapping
    const r = im.data[i] * (0.95 + 0.10 * Math.pow(v,2));
    const g = im.data[i+1] * (0.96 + 0.06 * (1 - v));
    const b = im.data[i+2] * (0.88 + 0.18 * Math.sin(v * 10));
    im.data[i] = Math.min(255, r + (v*12));
    im.data[i+1] = Math.min(255, g);
    im.data[i+2] = Math.min(255, b);
  }
  ctx.putImageData(im, 0, 0);
}

// bump map (stronger contrast)
const bumpCanvas = generateNoise(1024, 512, 6);
const colorTexture = new THREE.CanvasTexture(colorTexCanvas);
colorTexture.wrapS = colorTexture.wrapT = THREE.RepeatWrapping;
colorTexture.repeat.set(1,1);
colorTexture.encoding = THREE.sRGBEncoding;

const bumpTexture = new THREE.CanvasTexture(bumpCanvas);
bumpTexture.wrapS = bumpTexture.wrapT = THREE.RepeatWrapping;
bumpTexture.repeat.set(1,1);

// create Phobos sphere
const radius = 1.0;
const geometry = new THREE.SphereGeometry(radius, 128, 128);
const material = new THREE.MeshStandardMaterial({
  map: colorTexture,
  bumpMap: bumpTexture,
  bumpScale: 0.075,
  roughness: 0.85,
  metalness: 0.02,
  displacementMap: bumpTexture,
  displacementScale: 0.01
});
const phobos = new THREE.Mesh(geometry, material);
phobos.rotation.x = 0.07;
scene.add(phobos);

// subtle tilt and an orbiting 'showcase' ring to help 3D perception
const ringGeom = new THREE.TorusGeometry(radius*1.32, 0.002, 8, 120);
const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.03 });
const ring = new THREE.Mesh(ringGeom, ringMat);
ring.rotation.x = Math.PI / 2.9;
scene.add(ring);

// controls
const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.09;
controls.rotateSpeed = 0.45;
controls.zoomSpeed = 0.9;
controls.minDistance = 1.6;
controls.maxDistance = 8.5;
controls.autoRotate = false;

// Responsiveness
function onWindowResize(){
  const w = canvasWrap.clientWidth;
  const h = canvasWrap.clientHeight;
  renderer.setSize(w, h);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', onWindowResize, { passive: true });

// animate
let prevTime = performance.now();
function animate(now){
  const dt = (now - prevTime) / 1000;
  prevTime = now;

  // spin Phobos (subtle faster spin in Y, tiny wobble)
  phobos.rotation.y += dt * 0.25;  // base spin
  phobos.rotation.z = 0.02 * Math.sin(now * 0.0009);

  // ring rotation for depth
  ring.rotation.y += dt * 0.02;

  controls.update();
  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

// initial resize/fit
onWindowResize();

// small UI: toggle slow/fast spin via double click on canvas
let spinFactor = 1.0;
canvas.addEventListener('dblclick', () => {
  spinFactor = spinFactor === 1.0 ? 4.0 : 1.0;
  // adjust base spin by altering phobos rotation speed (we modify animate line)
  // But for simplicity we change controls autoRotate speed temporarily
  controls.autoRotateSpeed = spinFactor * 0.5;
  // flash the top badge color briefly
  const badge = document.querySelector('.badge');
  badge.style.transition = 'transform 0.18s ease, box-shadow 0.18s ease';
  badge.style.transform = 'scale(1.05)';
  setTimeout(()=> badge.style.transform = '', 180);
});

// accessibility: allow keyboard zoom
window.addEventListener('keydown', (e) => {
  if (e.key === '+' || e.key === '=') camera.position.z -= 0.3;
  if (e.key === '-') camera.position.z += 0.3;
});
</script>
</body>
</html>
